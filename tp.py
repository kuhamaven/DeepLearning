# -*- coding: utf-8 -*-
"""TP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LFbJ5Eii1tlbldLvOLDh3Z5HjzSoMcoT
"""

from google.colab import drive
import os

drive.mount('/content/drive', force_remount=True)

os.chdir('/content/drive/MyDrive/skin_cancer')
print(os.getcwd())

"""ResNet -
PyTorch

"""

pip install torch

import torch
import torch.optim as optim
import torch.nn as nn
import torchvision
import matplotlib.pyplot as plt
from torchvision import datasets, models, transforms

from tqdm import tqdm

device = 'cuda' if torch.cuda.is_available() else 'cpu'

"""Cargar los datasets"""

transform = transforms.Compose(
    [transforms.ToTensor(),
     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)), 
     transforms.Resize((200, 200))]
     )

batch_size = 24

trainset = datasets.ImageFolder('train', transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size,
                                          shuffle=True, num_workers=2)

testset = datasets.ImageFolder('Test', transform=transform)
testloader = torch.utils.data.DataLoader(testset, batch_size=batch_size,
                                         shuffle=False, num_workers=2)

"""Definir el modelo"""

lr = 0.0001
model = models.resnet50(pretrained = True)
num_ftrs = model.fc.in_features
model.fc = nn.Linear(num_ftrs, 9)
model.to(device)

loss_fn = nn.CrossEntropyLoss()

optimizer = optim.Adagrad(model.parameters(),lr = lr)

epochs = 9
losses = []

def make_train_step(model, loss_fn, optimizer):
    # Builds function that performs a step in the train loop
    def train_step(x, y):
        # Sets model to TRAIN mode
        model.train()
        # Makes predictions
        yhat = model(x)
        # Computes loss
        one_hot = torch.nn.functional.one_hot(y,num_classes=9)
        loss = torch.nn.functional.cross_entropy(yhat,torch.max(one_hot, 1)[1])
        # Computes gradients
        loss.backward()
        # Updates parameters and zeroes gradients
        optimizer.step()
        optimizer.zero_grad()
        # Returns the loss
        return loss.item()
    
    # Returns the function that will be called inside the train loop
    return train_step

# Creates the train_step function for our model, loss function and optimizer
train_step = make_train_step(model, loss_fn, optimizer)

"""
Cargar el modelo del drive
"""

model_save_name = '/content/drive/MyDrive/skin_cancer/modelo_OP.pt'
model.load_state_dict(torch.load(model_save_name))

"""Entrenar al modelo"""

#print(model.state_dict())

for epoch in range(1):
   for x_batch, y_batch in tqdm(trainloader):
        i = len(losses)
        x_batch = x_batch.to(device)
        y_batch = y_batch.to(device)
        # print(x_batch.shape)
        # print(y_batch.shape)
        loss = train_step(x_batch, y_batch)
        losses.append(loss)
        print('training loss')
        print(loss)

        # if i % 100 == 0:    # every 1000 mini-batches...

        #     # ...log the running loss
        #     writer.add_scalar('training loss',
        #                     running_loss / 1000,
        #                     epoch * len(trainloader) + i)

        #     # ...log a Matplotlib Figure showing the model's predictions on a
        #     # random mini-batch
        #     writer.add_figure('predictions vs. actuals',
        #                     plot_classes_preds(net, inputs, labels),
        #                     global_step=epoch * len(trainloader) + i)
        #     running_loss = 0.0

#print(model.state_dict())



"""Dejo comentariado el save para no ejecutarlo por error, igual le cambie el file name por lo mismo"""

model_save_name = '/content/drive/MyDrive/skin_cancer/modelo_OP_12epochs.pt'
torch.save(model.state_dict(), model_save_name)

from matplotlib import pyplot as plt
plt.plot(losses)
plt.show()

"""Subir y predecir sobre una imÃ¡gen"""

!pip install -Uqq fastbook
import fastbook
fastbook.setup_book()

from fastbook import *

uploader = widgets.FileUpload()
uploader

uploader.data[0]
img = PILImage.create(uploader.data[0])
img

model.eval()

# Preprocess and display image
from torchvision import transforms
norm = transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
inv_norm = transforms.Normalize((-0.5, -0.5, -0.5), (-0.5, -0.5, -0.5))
preprocess = transforms.Compose([
    transforms.Resize((200, 200)),
    transforms.ToTensor(),
    norm,
])
image_tensor = preprocess(img)
input_tensor = image_tensor.unsqueeze(0) # single-image batch as wanted by model
input_tensor = input_tensor.to(device) # send tensor to TPU

# Display resized and cropped image
fig, ax = plt.subplots(1, 2, figsize=(8, 4));
mnc_tensor = image_tensor.permute(1, 2, 0); # (C, M, N) -> (M, N, C)
ax[0].imshow(mnc_tensor);
ax[0].axis('off');
ax[0].set_title('preprocessed image');
inv_norm_tensor = inv_norm(image_tensor).permute(1, 2, 0);
ax[1].imshow(inv_norm_tensor);
ax[1].axis('off');
ax[1].set_title('inv_norm(preprocessed image)');

# Single prediction call
outputs = model(input_tensor)
print('outputs.device == {}'.format(outputs.device))
print(outputs)
prediction = outputs.max(dim=1).indices.item()
print(prediction)

"""Labels:"""

labels = {'actinic keratosis',
 'basal cell carcinoma',
 'dermatofibroma',
 'melanoma',
 'nevus',
 'pigmented benign keratosis',
 'seborrheic keratosis',
 'squamous cell carcinoma',
 'vascular lesion'}

def model_img_evaluate(model,img_path):
  img = Image.open(img_path)
  # Preprocess and display image
  norm = transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
  inv_norm = transforms.Normalize((-0.5, -0.5, -0.5), (-0.5, -0.5, -0.5))
  preprocess = transforms.Compose([
      transforms.Resize((200, 200)),
      transforms.ToTensor(),
      norm,
  ])
  image_tensor = preprocess(img)
  input_tensor = image_tensor.unsqueeze(0) # single-image batch as wanted by model
  input_tensor = input_tensor.to(device) # send tensor to TPU

  # Single prediction call
  outputs = model(input_tensor)
  #prediction = outputs.max(dim=1).indices.item()
  prediction = torch.topk(outputs,2).indices[0]
  return prediction;

from PIL import Image
from sklearn.metrics import ConfusionMatrixDisplay

model.eval()
total = 0;
correct = 0;
y_true = []
y_pred = []

for img in testset.imgs:
  image_filepath = os.getcwd()+"/"+img[0]
  y = img[1]
  y_hat = model_img_evaluate(model,image_filepath)
  if(y == y_hat[0] or y == y_hat[1]):
  #if(y == y_hat[0]):
    correct = correct + 1
    y_pred.append(y)
  else:
    y_pred.append(y_hat[0].item())
  y_true.append(y)
  total = total + 1

print(y_true)
print(y_pred)
print(correct)
print(total)
ConfusionMatrixDisplay.from_predictions(y_true, y_pred,display_labels=testset.classes,xticks_rotation='vertical')
plt.show()

"""Tensor Board"""

from torch.utils.tensorboard import SummaryWriter

# default `log_dir` is "runs" - we'll be more specific here
writer = SummaryWriter('runs/fashion_mnist_experiment_1')

# helper function to show an image
# (used in the `plot_classes_preds` function below)
def matplotlib_imshow(img, one_channel=False):
    if one_channel:
        img = img.mean(dim=0)
    img = img / 2 + 0.5     # unnormalize
    npimg = img.numpy()
    if one_channel:
        plt.imshow(npimg, cmap="Greys")
    else:
        plt.imshow(np.transpose(npimg, (1, 2, 0)))

# get some random training images
dataiter = iter(trainloader)
images, labels = dataiter.next()

# create grid of images
img_grid = torchvision.utils.make_grid(images)

# show images
matplotlib_imshow(img_grid, one_channel=True)

# write to tensorboard
writer.add_image('four_fashion_mnist_images', img_grid)

# helper functions

def images_to_probs(net, images):
    '''
    Generates predictions and corresponding probabilities from a trained
    network and a list of images
    '''
    output = net(images)
    # convert output probabilities to predicted class
    _, preds_tensor = torch.max(output, 1)
    preds = np.squeeze(preds_tensor.numpy())
    return preds, [F.softmax(el, dim=0)[i].item() for i, el in zip(preds, output)]


def plot_classes_preds(net, images, labels):
    '''
    Generates matplotlib Figure using a trained network, along with images
    and labels from a batch, that shows the network's top prediction along
    with its probability, alongside the actual label, coloring this
    information based on whether the prediction was correct or not.
    Uses the "images_to_probs" function.
    '''
    preds, probs = images_to_probs(net, images)
    # plot the images in the batch, along with predicted and true labels
    fig = plt.figure(figsize=(12, 48))
    for idx in np.arange(4):
        ax = fig.add_subplot(1, 4, idx+1, xticks=[], yticks=[])
        matplotlib_imshow(images[idx], one_channel=True)
        ax.set_title("{0}, {1:.1f}%\n(label: {2})".format(
            classes[preds[idx]],
            probs[idx] * 100.0,
            classes[labels[idx]]),
                    color=("green" if preds[idx]==labels[idx].item() else "red"))
    return fig

# Commented out IPython magic to ensure Python compatibility.
# %load_ext tensorboard
# %tensorboard --logdir=runs